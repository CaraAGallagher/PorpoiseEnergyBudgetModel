1:length(d[,1]) %in% rows.to.change
				all.rows <- 1:length(d[,1])
all.rows
all.rows[!(all.rows %in% rows.to.change)]
				row.to.keep <- all.rows[!(all.rows %in% rows.to.change)]
rows.to.change
				cont2 <- TRUE
cont2
rw
new.x[rw]
the.x
new.x
c(rw, rows.to.keep)
				rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]
c(rw, rows.to.keep)
new.x[c(rw, rows.to.keep)]
					e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])
e
				while (cont2) {#
					new.x[rw] <- round(out@ncols * runif(1), 0)#
					new.y[rw] <- round(out@nrows * runif(1), 0)#
					e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])#
					if (sum(e)==0) cont2 <- FALSE#
				}
e
sort(c(rw, rows.to.keep))
						rows.to.keep <- sort(c(rw, rows.to.keep))
				for (rw in rows.to.change) {#
					cont2 <- TRUE#
					while (cont2) {#
						new.x[rw] <- round(out@ncols * runif(1), 0)#
						new.y[rw] <- round(out@nrows * runif(1), 0)#
						e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])#
						if (sum(e)==0) {#
							cont2 <- FALSE#
							rows.to.keep <- sort(c(rw, rows.to.keep))#
						}#
					}#
				}
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points#
		new.x <- round(out@ncols * runif(n.patches), 0)#
		new.y <- round(out@nrows * runif(n.patches), 0)#
		cont <- TRUE
			# Replace patches too close to edges#
			x.to.change <- -9#
			while (length(x.to.change)>0) {#
				x.to.change <- which(new.x<size | new.x>(out@ncols-size))#
				new.x[x.to.change] <- round(out@ncols * runif(length(x.to.change)), 0)#
			}#
			y.to.change <- -9#
			while (length(y.to.change)>0) {#
				y.to.change <- which(new.y<size | new.y>(out@nrows-size))#
				new.y[y.to.change] <- round(out@nrows * runif(length(y.to.change)), 0)#
			}
			i <- 0#
			get.close.pairs <- function(the.x, the.y, s=size) {#
				a <- abs(outer(the.x, the.x, FUN="-"))#
				b <- abs(outer(the.y, the.y, FUN="-"))#
				c <- sqrt(a*a+b*b) < 2*s+1#
				c <- c & lower.tri(c)  # pairs of positions that are too close together#
				return (c)#
			}
				d <- get.close.pairs(new.x, new.y)
d
				data.frame(new.x, new.y)
(sum(d)==0)
				rows.to.change <- which(apply(d,1,sum)>=1)
rows.to.change
				all.rows <- 1:length(d[,1])#
				rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]
rows.to.keep
rw <- rows.to.change[1]
rw
					cont2 <- TRUE
					while (cont2) {#
						new.x[rw] <- round(out@ncols * runif(1), 0)#
						new.y[rw] <- round(out@nrows * runif(1), 0)#
						e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])#
						if (sum(e)==0) {#
							cont2 <- FALSE#
							rows.to.keep <- sort(c(rw, rows.to.keep))#
						}#
					}
cont2
rows.to.keep
e
				for (rw in rows.to.change) {#
					cont2 <- TRUE#
					while (cont2) {#
						new.x[rw] <- round(out@ncols * runif(1), 0)#
						new.y[rw] <- round(out@nrows * runif(1), 0)#
						e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])#
						if (sum(e)==0) {#
							cont2 <- FALSE#
							rows.to.keep <- sort(c(rw, rows.to.keep))#
						}#
					}#
				}
rm(list=ls())
library(trk)#
data(simple)#
object <- simple#
slotNames(object)#
plot(object)#
n.patches = 10#
type = "c"#
size = 2#
values=list(backgr=0, patch=1)#
keep.nodata=TRUE#
#
make.landscape <- function(object, n.patches, type, size, values, keep.nodata, ...) attributes(object)#
setGeneric("make.landscape")
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points#
		new.x <- round(out@ncols * runif(n.patches), 0)#
		new.y <- round(out@nrows * runif(n.patches), 0)#
		cont <- TRUE
			# Replace patches too close to edges#
			x.to.change <- -9#
			while (length(x.to.change)>0) {#
				x.to.change <- which(new.x<size | new.x>(out@ncols-size))#
				new.x[x.to.change] <- round(out@ncols * runif(length(x.to.change)), 0)#
			}#
			y.to.change <- -9#
			while (length(y.to.change)>0) {#
				y.to.change <- which(new.y<size | new.y>(out@nrows-size))#
				new.y[y.to.change] <- round(out@nrows * runif(length(y.to.change)), 0)#
			}
			# Try to avoid overlapping patches#
			i <- 0#
			get.close.pairs <- function(the.x, the.y, s=size) {#
				a <- abs(outer(the.x, the.x, FUN="-"))#
				b <- abs(outer(the.y, the.y, FUN="-"))#
				c <- sqrt(a*a+b*b) < 2*s+1#
				c <- c & lower.tri(c)  # pairs of positions that are too close together#
				return (c)#
			}
				d <- get.close.pairs(new.x, new.y)
d
				if (sum(d)==0) break#
				rows.to.change <- which(apply(d,1,sum)>=1)
rows.to.change
				all.rows <- 1:length(d[,1])#
				rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]
rows.to.keep
rw <- rows.to.change[1]
rw
					cont2 <- TRUE#
					while (cont2) {#
						new.x[rw] <- round(out@ncols * runif(1), 0)#
						new.y[rw] <- round(out@nrows * runif(1), 0)#
						e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])#
						if (sum(e)==0) {#
							cont2 <- FALSE#
							rows.to.keep <- sort(c(rw, rows.to.keep))#
						}#
					}
rw <- rows.to.change[2]
					cont2 <- TRUE#
					while (cont2) {#
						new.x[rw] <- round(out@ncols * runif(1), 0)#
						new.y[rw] <- round(out@nrows * runif(1), 0)#
						e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])#
						if (sum(e)==0) {#
							cont2 <- FALSE#
							rows.to.keep <- sort(c(rw, rows.to.keep))#
						}#
					}
e
rw <- rows.to.change[3]
					cont2 <- TRUE#
					while (cont2) {#
						new.x[rw] <- round(out@ncols * runif(1), 0)#
						new.y[rw] <- round(out@nrows * runif(1), 0)#
						e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])#
						if (sum(e)==0) {#
							cont2 <- FALSE#
							rows.to.keep <- sort(c(rw, rows.to.keep))#
						}#
					}
e
rw <- rows.to.change[4]
					cont2 <- TRUE#
					while (cont2) {#
						new.x[rw] <- round(out@ncols * runif(1), 0)#
						new.y[rw] <- round(out@nrows * runif(1), 0)#
						e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])#
						if (sum(e)==0) {#
							cont2 <- FALSE#
							rows.to.keep <- sort(c(rw, rows.to.keep))#
						}#
					}
e
rw <- rows.to.change[5]
					cont2 <- TRUE#
					while (cont2) {#
						new.x[rw] <- round(out@ncols * runif(1), 0)#
						new.y[rw] <- round(out@nrows * runif(1), 0)#
						e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])#
						if (sum(e)==0) {#
							cont2 <- FALSE#
							rows.to.keep <- sort(c(rw, rows.to.keep))#
						}#
					}#
				}
					cont2 <- TRUE#
					while (cont2) {#
						new.x[rw] <- round(out@ncols * runif(1), 0)#
						new.y[rw] <- round(out@nrows * runif(1), 0)#
						e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])#
						if (sum(e)==0) {#
							cont2 <- FALSE#
							rows.to.keep <- sort(c(rw, rows.to.keep))#
						}#
					}
e
				print(data.frame(new.x, new.y))
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points#
		new.x <- round(out@ncols * runif(n.patches), 0)#
		new.y <- round(out@nrows * runif(n.patches), 0)#
		cont <- TRUE#
		while(cont) {#
			# Replace patches too close to edges#
			x.to.change <- -9#
			while (length(x.to.change)>0) {#
				x.to.change <- which(new.x<size | new.x>(out@ncols-size))#
				new.x[x.to.change] <- round(out@ncols * runif(length(x.to.change)), 0)#
			}#
			y.to.change <- -9#
			while (length(y.to.change)>0) {#
				y.to.change <- which(new.y<size | new.y>(out@nrows-size))#
				new.y[y.to.change] <- round(out@nrows * runif(length(y.to.change)), 0)#
			}#
#
			# Try to avoid overlapping patches#
			i <- 0#
			get.close.pairs <- function(the.x, the.y, s=size) {#
				a <- abs(outer(the.x, the.x, FUN="-"))#
				b <- abs(outer(the.y, the.y, FUN="-"))#
				c <- sqrt(a*a+b*b) < 2*s+1#
				c <- c & lower.tri(c)  # pairs of positions that are too close together#
				return (c)#
			}#
			while (i < 100) {#
				d <- get.close.pairs(new.x, new.y)#
				if (sum(d)==0) break#
				rows.to.change <- which(apply(d,1,sum)>=1)#
				all.rows <- 1:length(d[,1])#
				rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
				# Change one row at a time, and check if the new point are far enough from others#
				#rw <- rows.to.change[1]#
				print(data.frame(new.x, new.y))#
				for (rw in rows.to.change) {#
					cont2 <- TRUE#
					stopval<-1#
					while (cont2 && stopval<1000) {#
						new.x[rw] <- round(out@ncols * runif(1), 0)#
						new.y[rw] <- round(out@nrows * runif(1), 0)#
						e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])#
						if (sum(e)==0) {#
							cont2 <- FALSE#
							rows.to.keep <- sort(c(rw, rows.to.keep))#
						}#
						stopval <- stopval+1#
					}#
					if(stopval==1000) warning("couldn't find point sufficiently far from the others")#
				}#
				print(data.frame(new.x, new.y))#
				i <- i+1	#
			}#
			# Check dist to edge again:#
			x.to.change <- which(new.x<size | new.x>(out@ncols-size))#
			y.to.change <- which(new.y<size | new.y>(out@nrows-size))#
			if (length(x.to.change)==0 && length(y.to.change)==0) cont <- FALSE#
		} # end cont#
#
		if (sum(c)>0) warning("Some patch centres are closer than 2*size+1 from each other")#
		# Make new patches#
		for (j in 1:length(new.x)) {#
			out@data[new.y[j],new.x[j]] <- values[["patch"]]#
		}#
		plot(out)
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points#
		new.x <- round(out@ncols * runif(n.patches), 0)#
		new.y <- round(out@nrows * runif(n.patches), 0)#
		cont <- TRUE#
		while(cont) {#
			# Replace patches too close to edges#
			x.to.change <- -9#
			while (length(x.to.change)>0) {#
				x.to.change <- which(new.x<size | new.x>(out@ncols-size))#
				new.x[x.to.change] <- round(out@ncols * runif(length(x.to.change)), 0)#
			}#
			y.to.change <- -9#
			while (length(y.to.change)>0) {#
				y.to.change <- which(new.y<size | new.y>(out@nrows-size))#
				new.y[y.to.change] <- round(out@nrows * runif(length(y.to.change)), 0)#
			}#
#
			# Try to avoid overlapping patches#
			i <- 0#
			get.close.pairs <- function(the.x, the.y, s=size) {#
				a <- abs(outer(the.x, the.x, FUN="-"))#
				b <- abs(outer(the.y, the.y, FUN="-"))#
				c <- sqrt(a*a+b*b) < 2*s+1#
				c <- c & lower.tri(c)  # pairs of positions that are too close together#
				return (c)#
			}#
			while (i < 100) {#
				d <- get.close.pairs(new.x, new.y)#
				if (sum(d)==0) break#
				rows.to.change <- which(apply(d,1,sum)>=1)#
				all.rows <- 1:length(d[,1])#
				rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
				# Change one row at a time, and check if the new point are far enough from others#
				#rw <- rows.to.change[1]#
				print(data.frame(new.x, new.y))#
				for (rw in rows.to.change) {#
					cont2 <- TRUE#
					stopval<-1#
					print(paste("Row to chg:", rw))#
					while (cont2 && stopval<1000) {#
						new.x[rw] <- round(out@ncols * runif(1), 0)#
						new.y[rw] <- round(out@nrows * runif(1), 0)#
						e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])#
						if (sum(e)==0) {#
							cont2 <- FALSE#
							rows.to.keep <- sort(c(rw, rows.to.keep))#
						}#
						stopval <- stopval+1#
					}#
					if(stopval==1000) warning("couldn't find point sufficiently far from the others")#
				}#
				print(data.frame(new.x, new.y))#
				i <- i+1	#
			}#
			# Check dist to edge again:#
			x.to.change <- which(new.x<size | new.x>(out@ncols-size))#
			y.to.change <- which(new.y<size | new.y>(out@nrows-size))#
			if (length(x.to.change)==0 && length(y.to.change)==0) cont <- FALSE#
		} # end cont#
#
		#if (sum(c)>0) warning("Some patch centres are closer than 2*size+1 from each other")#
		# Make new patches#
		for (j in 1:length(new.x)) {#
			out@data[new.y[j],new.x[j]] <- values[["patch"]]#
		}#
		plot(out)
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points#
		new.x <- round(out@ncols * runif(n.patches), 0)#
		new.y <- round(out@nrows * runif(n.patches), 0)#
		cont <- TRUE#
		while(cont) {#
			# Replace patches too close to edges#
			x.to.change <- -9#
			while (length(x.to.change)>0) {#
				x.to.change <- which(new.x<size | new.x>(out@ncols-size))#
				new.x[x.to.change] <- round(out@ncols * runif(length(x.to.change)), 0)#
			}#
			y.to.change <- -9#
			while (length(y.to.change)>0) {#
				y.to.change <- which(new.y<size | new.y>(out@nrows-size))#
				new.y[y.to.change] <- round(out@nrows * runif(length(y.to.change)), 0)#
			}#
#
			# Try to avoid overlapping patches#
			i <- 0#
			get.close.pairs <- function(the.x, the.y, s=size) {#
				a <- abs(outer(the.x, the.x, FUN="-"))#
				b <- abs(outer(the.y, the.y, FUN="-"))#
				c <- sqrt(a*a+b*b) < 2*s+1#
				c <- c & lower.tri(c)  # pairs of positions that are too close together#
				return (c)#
			}#
			while (i < 100) {#
				d <- get.close.pairs(new.x, new.y)#
				if (sum(d)==0) break#
				rows.to.change <- which(apply(d,1,sum)>=1)#
				all.rows <- 1:length(d[,1])#
				rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
				# Change one row at a time, and check if the new point are far enough from others#
				#rw <- rows.to.change[1]#
				print(data.frame(new.x, new.y))#
				for (rw in rows.to.change) {#
					cont2 <- TRUE#
					stopval<-1#
					print(paste("Row to chg:", rw))#
					while (cont2 && stopval<1000) {#
						new.x[rw] <- round(out@ncols * runif(1), 0)#
						new.y[rw] <- round(out@nrows * runif(1), 0)#
						e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])#
						if (sum(e)==0) {#
							cont2 <- FALSE#
							rows.to.keep <- sort(c(rw, rows.to.keep))#
						}#
						stopval <- stopval+1#
					}#
					if(stopval==1000) warning("couldn't find point sufficiently far from the others")#
					print(data.frame(new.x, new.y))#
				}#
				i <- i+1	#
			}#
			# Check dist to edge again:#
			x.to.change <- which(new.x<size | new.x>(out@ncols-size))#
			y.to.change <- which(new.y<size | new.y>(out@nrows-size))#
			if (length(x.to.change)==0 && length(y.to.change)==0) cont <- FALSE#
		} # end cont#
#
		#if (sum(c)>0) warning("Some patch centres are closer than 2*size+1 from each other")#
		# Make new patches#
		for (j in 1:length(new.x)) {#
			out@data[new.y[j],new.x[j]] <- values[["patch"]]#
		}#
		plot(out)
size
size<-3
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points#
		new.x <- round(out@ncols * runif(n.patches), 0)#
		new.y <- round(out@nrows * runif(n.patches), 0)#
		cont <- TRUE#
		while(cont) {#
			# Replace patches too close to edges#
			x.to.change <- -9#
			while (length(x.to.change)>0) {#
				x.to.change <- which(new.x<size | new.x>(out@ncols-size))#
				new.x[x.to.change] <- round(out@ncols * runif(length(x.to.change)), 0)#
			}#
			y.to.change <- -9#
			while (length(y.to.change)>0) {#
				y.to.change <- which(new.y<size | new.y>(out@nrows-size))#
				new.y[y.to.change] <- round(out@nrows * runif(length(y.to.change)), 0)#
			}#
#
			# Try to avoid overlapping patches#
			i <- 0#
			get.close.pairs <- function(the.x, the.y, s=size) {#
				a <- abs(outer(the.x, the.x, FUN="-"))#
				b <- abs(outer(the.y, the.y, FUN="-"))#
				c <- sqrt(a*a+b*b) < 2*s+1#
				c <- c & lower.tri(c)  # pairs of positions that are too close together#
				return (c)#
			}#
			while (i < 100) {#
				d <- get.close.pairs(new.x, new.y)#
				if (sum(d)==0) break#
				rows.to.change <- which(apply(d,1,sum)>=1)#
				all.rows <- 1:length(d[,1])#
				rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
				# Change one row at a time, and check if the new point are far enough from others#
				#rw <- rows.to.change[1]#
				print(data.frame(new.x, new.y))#
				for (rw in rows.to.change) {#
					cont2 <- TRUE#
					stopval<-1#
					print(paste("Row to chg:", rw))#
					while (cont2 && stopval<1000) {#
						new.x[rw] <- round(out@ncols * runif(1), 0)#
						new.y[rw] <- round(out@nrows * runif(1), 0)#
						e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])#
						if (sum(e)==0) {#
							cont2 <- FALSE#
							rows.to.keep <- sort(c(rw, rows.to.keep))#
						}#
						stopval <- stopval+1#
					}#
					if(stopval==1000) warning("couldn't find point sufficiently far from the others")#
					print(data.frame(new.x, new.y))#
				}#
				i <- i+1	#
			}#
			# Check dist to edge again:#
			x.to.change <- which(new.x<size | new.x>(out@ncols-size))#
			y.to.change <- which(new.y<size | new.y>(out@nrows-size))#
			if (length(x.to.change)==0 && length(y.to.change)==0) cont <- FALSE#
		} # end cont#
#
		#if (sum(c)>0) warning("Some patch centres are closer than 2*size+1 from each other")#
		# Make new patches#
		for (j in 1:length(new.x)) {#
			out@data[new.y[j],new.x[j]] <- values[["patch"]]#
		}#
		plot(out)
warnings()
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points#
		new.x <- round(out@ncols * runif(n.patches), 0)#
		new.y <- round(out@nrows * runif(n.patches), 0)#
		cont <- TRUE#
		while(cont) {#
			# Replace patches too close to edges#
			x.to.change <- -9#
			while (length(x.to.change)>0) {#
				x.to.change <- which(new.x<size | new.x>(out@ncols-size))#
				new.x[x.to.change] <- round(out@ncols * runif(length(x.to.change)), 0)#
			}#
			y.to.change <- -9#
			while (length(y.to.change)>0) {#
				y.to.change <- which(new.y<size | new.y>(out@nrows-size))#
				new.y[y.to.change] <- round(out@nrows * runif(length(y.to.change)), 0)#
			}#
#
			# Try to avoid overlapping patches#
			i <- 0#
			get.close.pairs <- function(the.x, the.y, s=size) {#
				a <- abs(outer(the.x, the.x, FUN="-"))#
				b <- abs(outer(the.y, the.y, FUN="-"))#
				c <- sqrt(a*a+b*b) < 2*s+1#
				c <- c & lower.tri(c)  # pairs of positions that are too close together#
				return (c)#
			}#
			while (i < 100) {#
				d <- get.close.pairs(new.x, new.y)#
				if (sum(d)==0) break#
				rows.to.change <- which(apply(d,1,sum)>=1)#
				all.rows <- 1:length(d[,1])#
				rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
				# Change one row at a time, and check if the new point are far enough from others#
				#rw <- rows.to.change[1]#
				print(data.frame(new.x, new.y))#
				for (rw in rows.to.change) {#
					cont2 <- TRUE#
					stopval<-1#
					print(paste("Row to chg:", rw))#
					while (cont2 && stopval<100) {#
						new.x[rw] <- round(out@ncols * runif(1), 0)#
						new.y[rw] <- round(out@nrows * runif(1), 0)#
						e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])#
						if (sum(e)==0) {#
							cont2 <- FALSE#
							rows.to.keep <- sort(c(rw, rows.to.keep))#
						}#
						stopval <- stopval+1#
					}#
					if(stopval==100) warning(paste("Couldn't disperse point", rw))#
					print(data.frame(new.x, new.y))#
				}#
				i <- i+1	#
			}#
			# Check dist to edge again:#
			x.to.change <- which(new.x<size | new.x>(out@ncols-size))#
			y.to.change <- which(new.y<size | new.y>(out@nrows-size))#
			if (length(x.to.change)==0 && length(y.to.change)==0) cont <- FALSE#
		} # end cont#
#
		#if (sum(c)>0) warning("Some patch centres are closer than 2*size+1 from each other")#
		# Make new patches#
		for (j in 1:length(new.x)) {#
			out@data[new.y[j],new.x[j]] <- values[["patch"]]#
		}#
		plot(out)
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points#
		new.x <- round(out@ncols * runif(n.patches), 0)#
		new.y <- round(out@nrows * runif(n.patches), 0)#
		cont <- TRUE#
		while(cont) {#
			# Replace patches too close to edges#
			x.to.change <- -9#
			while (length(x.to.change)>0) {#
				x.to.change <- which(new.x<size | new.x>(out@ncols-size))#
				new.x[x.to.change] <- round(out@ncols * runif(length(x.to.change)), 0)#
			}#
			y.to.change <- -9#
			while (length(y.to.change)>0) {#
				y.to.change <- which(new.y<size | new.y>(out@nrows-size))#
				new.y[y.to.change] <- round(out@nrows * runif(length(y.to.change)), 0)#
			}#
#
			get.close.pairs <- function(the.x, the.y, s=size) {#
				a <- abs(outer(the.x, the.x, FUN="-"))#
				b <- abs(outer(the.y, the.y, FUN="-"))#
				c <- sqrt(a*a+b*b) < 2*s+1#
				c <- c & lower.tri(c)  # pairs of positions that are too close together#
				return (c)#
			}#
#			i <- 0#
#			while (i < 100) {#
			# Try to avoid overlapping patches#
				d <- get.close.pairs(new.x, new.y)#
				if (sum(d)==0) break#
				rows.to.change <- which(apply(d,1,sum)>=1)#
				all.rows <- 1:length(d[,1])#
				rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
				# Change one row at a time, and check if the new point are far enough from others#
				#rw <- rows.to.change[1]#
				print(data.frame(new.x, new.y))#
				for (rw in rows.to.change) {#
					cont2 <- TRUE#
					stopval<-1#
					print(paste("Row to chg:", rw))#
					while (cont2 && stopval<100) {#
						new.x[rw] <- round(out@ncols * runif(1), 0)#
						new.y[rw] <- round(out@nrows * runif(1), 0)#
						e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])#
						if (sum(e)==0) {#
							cont2 <- FALSE#
							rows.to.keep <- sort(c(rw, rows.to.keep))#
						}#
						stopval <- stopval+1#
					}#
					if(stopval==100) warning(paste("Couldn't disperse point", rw))#
				}#
#				i <- i+1	#
			}#
			# Check dist to edge again:#
			x.to.change <- which(new.x<size | new.x>(out@ncols-size))#
			y.to.change <- which(new.y<size | new.y>(out@nrows-size))#
			if (length(x.to.change)==0 && length(y.to.change)==0) cont <- FALSE#
		} # end cont#
#
		#if (sum(c)>0) warning("Some patch centres are closer than 2*size+1 from each other")#
		# Make new patches#
		for (j in 1:length(new.x)) {#
			out@data[new.y[j],new.x[j]] <- values[["patch"]]#
		}#
		plot(out)
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points#
		new.x <- round(out@ncols * runif(n.patches), 0)#
		new.y <- round(out@nrows * runif(n.patches), 0)#
		#
		get.close.pairs <- function(the.x, the.y, s=size) {#
			# Try to avoid overlapping patches#
			a <- abs(outer(the.x, the.x, FUN="-"))#
			b <- abs(outer(the.y, the.y, FUN="-"))#
			c <- sqrt(a*a+b*b) < 2*s+1#
			c <- c & lower.tri(c)  # pairs of positions that are too close together#
			rows.to.change <- which(apply(c,1,sum)>=1)#
			return (rows.to.change)#
		}#
		too.close.to.edge <- function(the.x, the.y, s=size) {#
			# Check if patch overlaps with edge#
			if(the.x<size | the.x>(out@ncols-size)) return(TRUE)#
			if(the.y<size | the.y>(out@nrows-size)) return(TRUE)#
			return(FALSE)#
		}
				d <- get.close.pairs(new.x, new.y)
d
				all.rows <- 1:length(d[,1])#
				rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]
rows.to.keep
				all.rows <- 1:length(new.x)
				rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]
rows.to.keep
rows.to.change
rw <- rows.to.change[1]
				print(data.frame(new.x, new.y))
rw <- rows.to.change[1]
				print(data.frame(new.x, new.y))
					cont2 <- TRUE
					stopval<-1
					print(paste("Row to chg:", rw))
						e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])
e
rw
(length(e)==0)
too.close.to.edge(new.x[rw], new.y[rw])
new.x[rw]
new.y[rw]
						move.from.edge <- too.close.to.edge(new.x[rw], new.y[rw])
move.from.edge
					while (cont2 && stopval<100) {#
						new.x[rw] <- round(out@ncols * runif(1), 0)#
						new.y[rw] <- round(out@nrows * runif(1), 0)#
						move.from.edge <- too.close.to.edge(new.x[rw], new.y[rw])#
						e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])#
						if (length(e)==0 & !move.from.edge) {#
							cont2 <- FALSE#
							rows.to.keep <- sort(c(rw, rows.to.keep))#
						}#
						stopval <- stopval+1#
					}#
					if(stopval==100) warning(paste("Couldn't disperse point", rw))
rows.to.change
 round(out@ncols * runif(1), 0)
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points#
		new.x <- round(out@ncols * runif(n.patches), 0)#
		new.y <- round(out@nrows * runif(n.patches), 0)#
		#
		get.close.pairs <- function(the.x, the.y, s=size) {#
			# Try to avoid overlapping patches#
			a <- abs(outer(the.x, the.x, FUN="-"))#
			b <- abs(outer(the.y, the.y, FUN="-"))#
			c <- sqrt(a*a+b*b) < 2*s+1#
			c <- c & lower.tri(c)  # pairs of positions that are too close together#
			rows.to.change <- which(apply(c,1,sum)>=1)#
			return (rows.to.change)#
		}#
		too.close.to.edge <- function(the.x, the.y, s=size) {#
			# Check if patch overlaps with edge#
			if(the.x<size | the.x>(out@ncols-size)) return(TRUE)#
			if(the.y<size | the.y>(out@nrows-size)) return(TRUE)#
			return(FALSE)#
		}#
#
#		cont <- TRUE#
#		while(cont) {#
#			# Replace patches too close to edges#
#			x.to.change <- -9#
#			while (length(x.to.change)>0) {#
#				x.to.change <- which(new.x<size | new.x>(out@ncols-size))#
#				new.x[x.to.change] <- round(out@ncols * runif(length(x.to.change)), 0)#
#			}#
#			y.to.change <- -9#
#			while (length(y.to.change)>0) {#
#				y.to.change <- which(new.y<size | new.y>(out@nrows-size))#
#				new.y[y.to.change] <- round(out@nrows * runif(length(y.to.change)), 0)#
#			}#
##
#			i <- 0#
#			while (i < 100) {#
	#
	#
			# Try to avoid overlapping patches#
				rows.to.change <- get.close.pairs(new.x, new.y)#
#				if (sum(d)==0) break#
#				rows.to.change <- which(apply(d,1,sum)>=1)#
				all.rows <- 1:length(new.x)#
				rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
				# Change one row at a time, and check if the new point are far enough from others#
				#rw <- rows.to.change[1]#
				print(data.frame(new.x, new.y))#
				for (rw in rows.to.change) {#
					cont2 <- TRUE#
					stopval<-1#
					print(paste("Row to chg:", rw))#
					while (cont2 && stopval<100) {#
						new.x[rw] <- round(out@ncols * runif(1), 0)#
						new.y[rw] <- round(out@nrows * runif(1), 0)#
						move.from.edge <- too.close.to.edge(new.x[rw], new.y[rw])#
						e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])#
						if (length(e)==0 & !move.from.edge) {#
							cont2 <- FALSE#
							rows.to.keep <- sort(c(rw, rows.to.keep))#
						}#
						stopval <- stopval+1#
					}#
					if(stopval==100) warning(paste("Couldn't disperse point", rw))#
				}#
#				i <- i+1	#
			}#
			# Check dist to edge again:#
			x.to.change <- which(new.x<size | new.x>(out@ncols-size))#
			y.to.change <- which(new.y<size | new.y>(out@nrows-size))#
			if (length(x.to.change)==0 && length(y.to.change)==0) cont <- FALSE#
		} # end cont#
#
		#if (sum(c)>0) warning("Some patch centres are closer than 2*size+1 from each other")#
		# Make new patches#
		for (j in 1:length(new.x)) {#
			out@data[new.y[j],new.x[j]] <- values[["patch"]]#
		}#
		plot(out)
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points#
		new.x <- round(out@ncols * runif(n.patches), 0)#
		new.y <- round(out@nrows * runif(n.patches), 0)#
		#
		get.close.pairs <- function(the.x, the.y, s=size) {#
			# Try to avoid overlapping patches#
			a <- abs(outer(the.x, the.x, FUN="-"))#
			b <- abs(outer(the.y, the.y, FUN="-"))#
			c <- sqrt(a*a+b*b) < 2*s+1#
			c <- c & lower.tri(c)  # pairs of positions that are too close together#
			rows.to.change <- which(apply(c,1,sum)>=1)#
			return (rows.to.change)#
		}#
		too.close.to.edge <- function(the.x, the.y, s=size) {#
			# Check if patch overlaps with edge#
			if(the.x<size | the.x>(out@ncols-size)) return(TRUE)#
			if(the.y<size | the.y>(out@nrows-size)) return(TRUE)#
			return(FALSE)#
		}#
#
#		cont <- TRUE#
#		while(cont) {#
#			# Replace patches too close to edges#
#			x.to.change <- -9#
#			while (length(x.to.change)>0) {#
#				x.to.change <- which(new.x<size | new.x>(out@ncols-size))#
#				new.x[x.to.change] <- round(out@ncols * runif(length(x.to.change)), 0)#
#			}#
#			y.to.change <- -9#
#			while (length(y.to.change)>0) {#
#				y.to.change <- which(new.y<size | new.y>(out@nrows-size))#
#				new.y[y.to.change] <- round(out@nrows * runif(length(y.to.change)), 0)#
#			}#
##
#			i <- 0#
#			while (i < 100) {#
	#
	#
			# Try to avoid overlapping patches#
				rows.to.change <- get.close.pairs(new.x, new.y)#
#				if (sum(d)==0) break#
#				rows.to.change <- which(apply(d,1,sum)>=1)#
				all.rows <- 1:length(new.x)#
				rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
				# Change one row at a time, and check if the new point are far enough from others#
				#rw <- rows.to.change[1]#
				print(data.frame(new.x, new.y))#
				for (rw in rows.to.change) {#
					cont2 <- TRUE#
					stopval<-1#
					print(paste("Row to chg:", rw))#
					while (cont2 && stopval<100) {#
						new.x[rw] <- round(out@ncols * runif(1), 0)#
						new.y[rw] <- round(out@nrows * runif(1), 0)#
						move.from.edge <- too.close.to.edge(new.x[rw], new.y[rw])#
						e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])#
						if (length(e)==0 & !move.from.edge) {#
							cont2 <- FALSE#
							rows.to.keep <- sort(c(rw, rows.to.keep))#
						}#
						stopval <- stopval+1#
					}#
					if(stopval==100) warning(paste("Couldn't disperse point", rw))#
				}#
#				i <- i+1	#
			}#
			# Check dist to edge again:#
			x.to.change <- which(new.x<size | new.x>(out@ncols-size))#
			y.to.change <- which(new.y<size | new.y>(out@nrows-size))#
			if (length(x.to.change)==0 && length(y.to.change)==0) cont <- FALSE#
#		} # end cont#
#
		#if (sum(c)>0) warning("Some patch centres are closer than 2*size+1 from each other")#
		# Make new patches#
		for (j in 1:length(new.x)) {#
			out@data[new.y[j],new.x[j]] <- values[["patch"]]#
		}#
		plot(out)
		print(data.frame(new.x, new.y))
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points#
		new.x <- round(out@ncols * runif(n.patches), 0)#
		new.y <- round(out@nrows * runif(n.patches), 0)#
		#
		get.close.pairs <- function(the.x, the.y, s=size) {#
			# Try to avoid overlapping patches#
			a <- abs(outer(the.x, the.x, FUN="-"))#
			b <- abs(outer(the.y, the.y, FUN="-"))#
			c <- sqrt(a*a+b*b) < 2*s+1#
			c <- c & lower.tri(c)  # pairs of positions that are too close together#
			rows.to.change <- which(apply(c,1,sum)>=1)#
			return (rows.to.change)#
		}#
		too.close.to.edge <- function(the.x, the.y, s=size) {#
			# Check if patch overlaps with edge#
			if(the.x<size | the.x>(out@ncols-size)) return(TRUE)#
			if(the.y<size | the.y>(out@nrows-size)) return(TRUE)#
			return(FALSE)#
		}#
#
#		cont <- TRUE#
#		while(cont) {#
#			# Replace patches too close to edges#
#			x.to.change <- -9#
#			while (length(x.to.change)>0) {#
#				x.to.change <- which(new.x<size | new.x>(out@ncols-size))#
#				new.x[x.to.change] <- round(out@ncols * runif(length(x.to.change)), 0)#
#			}#
#			y.to.change <- -9#
#			while (length(y.to.change)>0) {#
#				y.to.change <- which(new.y<size | new.y>(out@nrows-size))#
#				new.y[y.to.change] <- round(out@nrows * runif(length(y.to.change)), 0)#
#			}#
##
#			i <- 0#
#			while (i < 100) {#
	#
	#
			# Try to avoid overlapping patches#
				rows.to.change <- get.close.pairs(new.x, new.y)#
#				if (sum(d)==0) break#
#				rows.to.change <- which(apply(d,1,sum)>=1)#
				all.rows <- 1:length(new.x)#
				rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
				# Change one row at a time, and check if the new point are far enough from others#
				#rw <- rows.to.change[1]#
				print(data.frame(new.x, new.y))#
				for (rw in rows.to.change) {#
					cont2 <- TRUE#
					stopval<-1#
					print(paste("Row to chg:", rw))#
					while (cont2 && stopval<100) {#
						new.x[rw] <- round(out@ncols * runif(1), 0)#
						new.y[rw] <- round(out@nrows * runif(1), 0)#
						move.from.edge <- too.close.to.edge(new.x[rw], new.y[rw])#
						e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])#
						if (length(e)==0 & !move.from.edge) {#
							cont2 <- FALSE#
							rows.to.keep <- sort(c(rw, rows.to.keep))#
						}#
						stopval <- stopval+1#
					}#
					#
					if(stopval==100) {#
						warning(paste("Couldn't disperse point", rw))#
						# Make sure that centres are at least distinct and inside landscape#
						cont2 <- TRUE#
						stopval<-1#
						print(paste("Row to chg:", rw))#
						while (cont2 && stopval<100) {#
							new.x[rw] <- round(out@ncols * runif(1), 0)#
							new.y[rw] <- round(out@nrows * runif(1), 0)#
							move.from.edge <- too.close.to.edge(new.x[rw], new.y[rw], size=1)#
							e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)], size=1)#
							if (length(e)==0 & !move.from.edge) {#
								cont2 <- FALSE#
								rows.to.keep <- sort(c(rw, rows.to.keep))#
							}#
							stopval <- stopval+1#
						}#
					}#
				}#
#				i <- i+1	#
			}#
			# Check dist to edge again:#
			x.to.change <- which(new.x<size | new.x>(out@ncols-size))#
			y.to.change <- which(new.y<size | new.y>(out@nrows-size))#
			if (length(x.to.change)==0 && length(y.to.change)==0) cont <- FALSE#
#		} # end cont#
#
		#if (sum(c)>0) warning("Some patch centres are closer than 2*size+1 from each other")#
		# Make new patches#
		for (j in 1:length(new.x)) {#
			out@data[new.y[j],new.x[j]] <- values[["patch"]]#
		}#
		plot(out)#
		print(data.frame(new.x, new.y))
size
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points#
		new.x <- round(out@ncols * runif(n.patches), 0)#
		new.y <- round(out@nrows * runif(n.patches), 0)#
		#
		get.close.pairs <- function(the.x, the.y, s=size) {#
			# Try to avoid overlapping patches#
			a <- abs(outer(the.x, the.x, FUN="-"))#
			b <- abs(outer(the.y, the.y, FUN="-"))#
			c <- sqrt(a*a+b*b) < 2*s+1#
			c <- c & lower.tri(c)  # pairs of positions that are too close together#
			rows.to.change <- which(apply(c,1,sum)>=1)#
			return (rows.to.change)#
		}#
		too.close.to.edge <- function(the.x, the.y, s=size) {#
			# Check if patch overlaps with edge#
			if(the.x<size | the.x>(out@ncols-size)) return(TRUE)#
			if(the.y<size | the.y>(out@nrows-size)) return(TRUE)#
			return(FALSE)#
		}
		rows.to.change <- get.close.pairs(new.x, new.y)#
		all.rows <- 1:length(new.x)#
		rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
		# Change one row at a time, and check if the new point are far enough from others#
		print(data.frame(new.x, new.y))
rows.to.change
		get.close.pairs <- function(the.x, the.y, s=size) {#
			# Try to avoid overlapping patches#
			a <- abs(outer(the.x, the.x, FUN="-"))#
			b <- abs(outer(the.y, the.y, FUN="-"))#
			c <- sqrt(a*a+b*b) < 2*s+1#
			c <- c & lower.tri(c)  # pairs of positions that are too close together#
			rows.to.change <- which(apply(c,1,sum)>=1)#
			return (c)#
			return (rows.to.change)#
		}#
		too.close.to.edge <- function(the.x, the.y, s=size) {#
			# Check if patch overlaps with edge#
			if(the.x<size | the.x>(out@ncols-size)) return(TRUE)#
			if(the.y<size | the.y>(out@nrows-size)) return(TRUE)#
			return(FALSE)#
		}
		rows.to.change <- get.close.pairs(new.x, new.y)
rows.to.change
		new.x <- round( (out@ncols-2*size) * runif(n.patches), 0)
new.x
		new.x <- size + round( (out@ncols-2*size) * runif(n.patches), 0)#
		new.y <- size + round( (out@nrows-2*size) * runif(n.patches), 0)#
		#
		get.close.pairs <- function(the.x, the.y, s=size) {#
			# Try to avoid overlapping patches#
			a <- abs(outer(the.x, the.x, FUN="-"))#
			b <- abs(outer(the.y, the.y, FUN="-"))#
			c <- sqrt(a*a+b*b) < 2*s+1#
			c <- c & lower.tri(c)  # pairs of positions that are too close together#
			rows.to.change <- which(apply(c,1,sum)>=1)#
			return (c)#
			return (rows.to.change)#
		}
		rows.to.change <- get.close.pairs(new.x, new.y)
rows.to.change
		all.rows <- 1:length(new.x)#
		rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
		# Change one row at a time, and check if the new point are far enough from others#
		print(data.frame(new.x, new.y))
size
size <-2
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points sufficiently far from edge of landscape#
		new.x <- size + round( (out@ncols-2*size) * runif(n.patches), 0)#
		new.y <- size + round( (out@nrows-2*size) * runif(n.patches), 0)#
		#
		get.close.pairs <- function(the.x, the.y, s=size) {#
			# Try to avoid overlapping patches#
			a <- abs(outer(the.x, the.x, FUN="-"))#
			b <- abs(outer(the.y, the.y, FUN="-"))#
			c <- sqrt(a*a+b*b) < 2*s+1#
			c <- c & lower.tri(c)  # pairs of positions that are too close together#
			rows.to.change <- which(apply(c,1,sum)>=1)#
			return (c)#
			return (rows.to.change)#
		}#
#
	#
		# Try to avoid overlapping patches#
		rows.to.change <- get.close.pairs(new.x, new.y)#
		all.rows <- 1:length(new.x)#
		rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
		# Change one row at a time, and check if the new point are far enough from others#
		print(data.frame(new.x, new.y))
		rows.to.change
		get.close.pairs <- function(the.x, the.y, s=size) {#
			# Try to avoid overlapping patches#
			a <- abs(outer(the.x, the.x, FUN="-"))#
			b <- abs(outer(the.y, the.y, FUN="-"))#
			c <- sqrt(a*a+b*b) < 2*s+1#
			c <- c & lower.tri(c)  # pairs of positions that are too close together#
			rows.to.change <- which(apply(c,1,sum)>=1)#
			#return (c)#
			return (rows.to.change)#
		}
		rows.to.change <- get.close.pairs(new.x, new.y)#
		all.rows <- 1:length(new.x)#
		rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
		# Change one row at a time, and check if the new point are far enough from others#
#
		print(data.frame(new.x, new.y))#
		rows.to.change
		get.close.pairs <- function(the.x, the.y, s=size) {#
			# Try to avoid overlapping patches#
			a <- abs(outer(the.x, the.x, FUN="-"))#
			b <- abs(outer(the.y, the.y, FUN="-"))#
			c <- sqrt(a*a+b*b) < 2*s+1#
			c <- c & lower.tri(c)  # pairs of positions that are too close together#
			rows.to.change <- which(apply(c,1,sum)>=1)#
			print(c)#
			return (rows.to.change)#
		}
		rows.to.change <- get.close.pairs(new.x, new.y)#
		all.rows <- 1:length(new.x)#
		rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
		# Change one row at a time, and check if the new point are far enough from others#
#
		print(data.frame(new.x, new.y))#
		rows.to.change
rw
			cont2 <- TRUE#
			stopval<-1#
			print(paste("Row to chg:", rw))
				new.x[rw] <- size + round(out@ncols-2*size * runif(1), 0)#
				new.y[rw] <- size + round(out@nrows-2*size * runif(1), 0)
new.x[rw]
new.y[rw]
size
				new.x[rw] <- size + round( (out@ncols-2*size) * runif(1), 0)#
				new.y[rw] <- size + round( (out@nrows-2*size) * runif(1), 0)
new.x[rw]
new.y[rw]
				e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)])
rows.to.keep
e
				e <- get.close.pairs(new.x[c(rows.to.keep, rw)], new.y[c(rows.to.keep, rw)])
			while (cont2 && stopval<100) {#
				new.x[rw] <- size + round( (out@ncols-2*size) * runif(1), 0)#
				new.y[rw] <- size + round( (out@nrows-2*size) * runif(1), 0)#
				e <- get.close.pairs(new.x[c(rows.to.keep, rw)], new.y[c(rows.to.keep, rw)])#
				if (length(e)==0) {#
					cont2 <- FALSE#
					rows.to.keep <- sort(c(rw, rows.to.keep))#
				}#
				stopval <- stopval+1#
			}
rows.to.keep
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points sufficiently far from edge of landscape#
		new.x <- size + round( (out@ncols-2*size) * runif(n.patches), 0)#
		new.y <- size + round( (out@nrows-2*size) * runif(n.patches), 0)#
		#
		get.close.pairs <- function(the.x, the.y, s=size) {#
			# Try to avoid overlapping patches#
			a <- abs(outer(the.x, the.x, FUN="-"))#
			b <- abs(outer(the.y, the.y, FUN="-"))#
			c <- sqrt(a*a+b*b) < 2*s+1#
			c <- c & lower.tri(c)  # pairs of positions that are too close together#
			rows.to.change <- which(apply(c,1,sum)>=1)#
			print(c)#
			return (rows.to.change)#
		}#
#
	#
		# Try to avoid overlapping patches#
		rows.to.change <- get.close.pairs(new.x, new.y)#
		all.rows <- 1:length(new.x)#
		rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
		# Change one row at a time, and check if the new point are far enough from others#
#
		print(data.frame(new.x, new.y))#
		rows.to.change#
#
		for (rw in rows.to.change) {#
			cont2 <- TRUE#
			stopval<-1#
			print(paste("Row to chg:", rw))#
			while (cont2 && stopval<100) {#
				new.x[rw] <- size + round( (out@ncols-2*size) * runif(1), 0)#
				new.y[rw] <- size + round( (out@nrows-2*size) * runif(1), 0)#
				e <- get.close.pairs(new.x[c(rows.to.keep, rw)], new.y[c(rows.to.keep, rw)])#
				if (length(e)==0) {#
					cont2 <- FALSE#
					rows.to.keep <- sort(c(rw, rows.to.keep))#
				}#
				stopval <- stopval+1#
			}#
			#
			if(stopval==100) {#
				warning(paste("Couldn't disperse point", rw))#
#				# Make sure that centres are at least distinct and inside landscape#
#				cont2 <- TRUE#
#				stopval<-1#
#				print(paste("Row to chg:", rw))#
#				while (cont2 && stopval<100) {#
#					new.x[rw] <- round(out@ncols * runif(1), 0)#
#					new.y[rw] <- round(out@nrows * runif(1), 0)#
#					move.from.edge <- too.close.to.edge(new.x[rw], new.y[rw], size=1)#
#					e <- get.close.pairs(new.x[c(rw, rows.to.keep)], new.y[c(rw, rows.to.keep)], size=1)#
#					if (length(e)==0 & !move.from.edge) {#
#						cont2 <- FALSE#
#						rows.to.keep <- sort(c(rw, rows.to.keep))#
#					}#
#					stopval <- stopval+1#
#				}#
			}#
		}#
		#
#
		# Make new patches#
		for (j in 1:length(new.x)) {#
			out@data[new.y[j],new.x[j]] <- values[["patch"]]#
		}#
#
		plot(out)#
		print(data.frame(new.x, new.y))
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points sufficiently far from edge of landscape#
		new.x <- size + round( (out@ncols-2*size) * runif(n.patches), 0)#
		new.y <- size + round( (out@nrows-2*size) * runif(n.patches), 0)#
		#
		get.close.pairs <- function(the.x, the.y, s=size) {#
			# Try to avoid overlapping patches#
			a <- abs(outer(the.x, the.x, FUN="-"))#
			b <- abs(outer(the.y, the.y, FUN="-"))#
			c <- sqrt(a*a+b*b) < 2*s+1#
			c <- c & lower.tri(c)  # pairs of positions that are too close together#
			rows.to.change <- which(apply(c,1,sum)>=1)#
			print(c)#
			return (rows.to.change)#
		}#
#
	#
		# Try to avoid overlapping patches#
		rows.to.change <- get.close.pairs(new.x, new.y)#
		all.rows <- 1:length(new.x)#
		rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
		# Change one row at a time, and check if the new point are far enough from others#
#
		print(data.frame(new.x, new.y))#
		rows.to.change#
#
		for (rw in rows.to.change) {#
			cont2 <- TRUE#
			stopval<-1#
			print(paste("Row to chg:", rw))#
			while (cont2 && stopval<100) {#
				new.x[rw] <- size + round( (out@ncols-2*size) * runif(1), 0)#
				new.y[rw] <- size + round( (out@nrows-2*size) * runif(1), 0)#
				e <- get.close.pairs(new.x[c(rows.to.keep, rw)], new.y[c(rows.to.keep, rw)])#
				if (length(e)==0) {#
					cont2 <- FALSE#
					rows.to.keep <- sort(c(rw, rows.to.keep))#
				}#
				stopval <- stopval+1#
			}#
			#
			if(stopval==100) {#
				warning(paste("Couldn't disperse point", rw))#
			}#
		}#
		#
#
		# Make new patches#
		for (j in 1:length(new.x)) {#
			out@data[new.y[j],new.x[j]] <- values[["patch"]]#
		}#
#
		plot(out)#
		print(data.frame(new.x, new.y))
slotNames(object)
				warning(paste("Couldn't disperse point", new.x[rw]+xllcorner, ",", new.y[rw]+yllcorner))
				warning(paste("Couldn't disperse point", new.x[rw]+out@xllcorner, ",", new.y[rw]+out@yllcorner))
				warning(paste("Couldn't disperse point ", new.x[rw]+out@xllcorner, ",", new.y[rw]+out@yllcorner, sep=""))
				warning(paste("Couldn't disperse point ", new.y[rw]+out@xllcorner, ",", new.x[rw]+out@yllcorner, sep=""))
				warning(paste("Couldn't disperse point ", (out@nrows-new.y[rw])+out@xllcorner, ",", new.x[rw]+out@yllcorner, sep=""))
out@nrows
new.y[rw]
#
setMethod("make.landscape", signature(object="raster"),#
	make.landscape <- function(object, n.patches, type = "c", size = 1, values=list(backgr=0, patch=1), keep.nodata=TRUE) {#
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points sufficiently far from edge of landscape#
		new.x <- size + round( (out@ncols-2*size) * runif(n.patches), 0)#
		new.y <- size + round( (out@nrows-2*size) * runif(n.patches), 0)#
		#
		get.close.pairs <- function(the.x, the.y, s=size) {#
			# Try to avoid overlapping patches#
			a <- abs(outer(the.x, the.x, FUN="-"))#
			b <- abs(outer(the.y, the.y, FUN="-"))#
			c <- sqrt(a*a+b*b) < 2*s+1#
			c <- c & lower.tri(c)  # pairs of positions that are too close together#
			rows.to.change <- which(apply(c,1,sum)>=1)#
			print(c)#
			return (rows.to.change)#
		}#
#
	#
		# Try to avoid overlapping patches#
		rows.to.change <- get.close.pairs(new.x, new.y)#
		all.rows <- 1:length(new.x)#
		rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
		# Change one row at a time, and check if the new point are far enough from others#
#
		print(data.frame(new.x, new.y))#
		rows.to.change#
#
		for (rw in rows.to.change) {#
			cont2 <- TRUE#
			stopval<-1#
			print(paste("Row to chg:", rw))#
			while (cont2 && stopval<100) {#
				new.x[rw] <- size + round( (out@ncols-2*size) * runif(1), 0)#
				new.y[rw] <- size + round( (out@nrows-2*size) * runif(1), 0)#
				e <- get.close.pairs(new.x[c(rows.to.keep, rw)], new.y[c(rows.to.keep, rw)])#
				if (length(e)==0) {#
					cont2 <- FALSE#
					rows.to.keep <- sort(c(rw, rows.to.keep))#
				}#
				stopval <- stopval+1#
			}#
			#
			if(stopval==100) {#
				warning(paste("Couldn't disperse point ")) #, (out@nrows-new.y[rw])+out@xllcorner, ",", new.x[rw]+out@yllcorner, sep=""))#
			}#
		}#
		#
#
		# Make new patches#
		for (j in 1:length(new.x)) {#
			out@data[new.y[j],new.x[j]] <- values[["patch"]]#
		}#
#
		plot(out)#
		print(data.frame(new.x, new.y))#
			#
		if (keep.nodata) out@data[object@data == object@NODATA_value] <- object@NODATA_value#
		return(out)#
	}#
)#
#
#
test <- make.landscape(simple, 10)#
plot(test)
test <- make.landscape(simple, 10, size=2)#
plot(test)
test <- make.landscape(simple, 10, size=3)#
plot(test)
test <- make.landscape(simple, 10, size=2)#
plot(test)
setMethod("make.landscape", signature(object="raster"),#
	make.landscape <- function(object, n.patches, type = "c", size = 1, values=list(backgr=0, patch=1), keep.nodata=TRUE) {#
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points sufficiently far from edge of landscape#
		new.x <- size + round( (out@ncols-2*size) * runif(n.patches), 0)#
		new.y <- size + round( (out@nrows-2*size) * runif(n.patches), 0)#
		#
		get.close.pairs <- function(the.x, the.y, s=size) {#
			# Try to avoid overlapping patches#
			a <- abs(outer(the.x, the.x, FUN="-"))#
			b <- abs(outer(the.y, the.y, FUN="-"))#
			c <- sqrt(a*a+b*b) < 2*s+1#
			c <- c & lower.tri(c)  # pairs of positions that are too close together#
			rows.to.change <- which(apply(c,1,sum)>=1)#
			#print(c)#
			return (rows.to.change)#
		}#
#
	#
		# Try to avoid overlapping patches#
		rows.to.change <- get.close.pairs(new.x, new.y)#
		all.rows <- 1:length(new.x)#
		rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
		# Change one row at a time, and check if the new point are far enough from others#
		for (rw in rows.to.change) {#
			cont2 <- TRUE#
			stopval<-1#
			#print(paste("Row to chg:", rw))#
			while (cont2 && stopval<100) {#
				new.x[rw] <- size + round( (out@ncols-2*size) * runif(1), 0)#
				new.y[rw] <- size + round( (out@nrows-2*size) * runif(1), 0)#
				e <- get.close.pairs(new.x[c(rows.to.keep, rw)], new.y[c(rows.to.keep, rw)])#
				if (length(e)==0) {#
					cont2 <- FALSE#
					rows.to.keep <- sort(c(rw, rows.to.keep))#
				}#
				stopval <- stopval+1#
			}#
			#
			if(stopval==100) {#
				warning(paste("Couldn't disperse point ")) #, (out@nrows-new.y[rw])+out@xllcorner, ",", new.x[rw]+out@yllcorner, sep=""))#
			}#
		}#
		#
#
		# Make new patches#
		for (j in 1:length(new.x)) {#
			out@data[new.y[j],new.x[j]] <- values[["patch"]]#
		}#
		if (keep.nodata) out@data[object@data == object@NODATA_value] <- object@NODATA_value#
		return(out)#
	}#
)
test <- make.landscape(simple, 10, size=2)#
plot(test)
library(trk)
?make.landscape
	data(simple)#
	test <- make.landscape(simple, n.patches = 10, type = "s", size = 2)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 4)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 2, type = "c", size = 4)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 2, type = "c", size = 3)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 2, type = "c", size = 5)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 2, type = "c", size = 6)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 2, type = "c", size = 7)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 2, type = "c", size = 3)#
	plot(test)
size <- 3
		sz2 <- ceiling(size/2)
					x <- y <- (-sz2+1):sz2#
					dist <- function(x, y) sqrt(x*x + y*y)#
					dist.m <- outer(x,y,dist)#
					dist.m <- dist.m <= sz2#
					dist.m.sz <- sum(dist.m)#
					dimnames(dist.m) <- list(x,y)
dist.m
					x <- y <- -sz2:sz2
					dist <- function(x, y) sqrt(x*x + y*y)#
					dist.m <- outer(x,y,dist)#
					dist.m <- dist.m <= sz2#
					dist.m.sz <- sum(dist.m)#
					dimnames(dist.m) <- list(x,y)
dist.m
# make.landscape method#
#
make.landscape <- function(object, n.patches, type, size, values, keep.nodata, ...) attributes(object)#
setGeneric("make.landscape")#
#
setMethod("make.landscape", "raster",#
	make.landscape <- function(object, n.patches, type = "c", size = 1, values=list(backgr=0, patch=1), keep.nodata=TRUE) {#
		# Size is diameter of circular (c) patches, or side length of square (s) patches#
		n.patches <- round(n.patches)#
		sz2 <- ceiling(size/2)#
		if (!(type %in% c("c", "s"))) stop ("Type must be either 'c' or 's'")#
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points sufficiently far from edge of landscape#
		new.x <- sz2 + 1+round( (out@ncols-2*sz2-1) * runif(n.patches), 0)#
		new.y <- sz2 + 1+round( (out@nrows-2*sz2-1) * runif(n.patches), 0)#
		#
		get.close.pairs <- function(the.x, the.y, s=sz2) {#
			# Try to avoid overlapping patches#
			a <- abs(outer(the.x, the.x, FUN="-"))#
			b <- abs(outer(the.y, the.y, FUN="-"))#
			c <- sqrt(a*a+b*b) < 2*s+1#
			c <- c & lower.tri(c)  # pairs of positions that are too close together#
			rows.to.change <- which(apply(c,1,sum)>=1)#
			#print(c)#
			return (rows.to.change)#
		}#
#
		# Try to avoid overlapping patches#
		rows.to.change <- get.close.pairs(new.x, new.y)#
		all.rows <- 1:length(new.x)#
		rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
		# Change one row at a time, and check if the new point are far enough from others#
		for (rw in rows.to.change) {#
			cont2 <- TRUE#
			stopval<-1#
			#print(paste("Row to chg:", rw))#
			while (cont2 && stopval<100) {#
				new.x[rw] <- sz2 + 1+round( (out@ncols-2*sz2-1) * runif(1), 0)#
				new.y[rw] <- sz2 + 1+round( (out@nrows-2*sz2-1) * runif(1), 0)#
				e <- get.close.pairs(new.x[c(rows.to.keep, rw)], new.y[c(rows.to.keep, rw)])#
				if (length(e)==0) {#
					cont2 <- FALSE#
					rows.to.keep <- sort(c(rw, rows.to.keep))#
				}#
				stopval <- stopval+1#
			}#
			#
			if(stopval==100) {#
				warning(paste("Couldn't disperse point ")) #, (out@nrows-new.y[rw])+out@xllcorner, ",", new.x[rw]+out@yllcorner, sep=""))#
			}#
		}#
		#
#
		# Make new patches#
		if (keep.nodata) out@data[object@data == object@NODATA_value] <- object@NODATA_value#
		patches.made <- 0#
		for (j in 1:length(new.x)) {#
			if (out@data[new.y[j],new.x[j]] != object@NODATA_value) {#
				out@data[new.y[j],new.x[j]] <- values[["patch"]]#
				patches.made <- patches.made + 1#
				if (keep.nodata) out@data[object@data == object@NODATA_value] <- object@NODATA_value#
#
				# type=c -> make circle#
				if(type=="c") {#
					x <- y <- -sz2:sz2#
					dist <- function(x, y) sqrt(x*x + y*y)#
					dist.m <- outer(x,y,dist)#
					dist.m <- dist.m <= sz2#
					dist.m.sz <- sum(dist.m)#
					dimnames(dist.m) <- list(x,y)#
					for (m in x){#
						for (n in y) {#
							if( dist.m[as.character(m), as.character(n)] ) {#
								out@data[new.y[j]+n, new.x[j]+m] <- values[["patch"]]#
							}#
						}#
					}#
				} # end type=="c"#
				if(type=="s") {#
					nos <- (-round(size/2)):floor(size/2)#
					x <- y <- nos[(length(nos)-size+1):length(nos)]#
					dist.m <- outer(x,y)#
					dist.m <- dist.m <= 999999#
					dist.m.sz <- sum(dist.m)#
					dimnames(dist.m) <- list(x,y)#
					for (m in x){#
						for (n in y) {#
							if( dist.m[as.character(m), as.character(n)] ) {#
								out@data[new.y[j]+n, new.x[j]+m] <- values[["patch"]]#
							}#
						}#
					}#
				} # end type=="s"#
				#
			}#
		}		#
		if (keep.nodata) out@data[object@data == object@NODATA_value] <- object@NODATA_value#
		out@id <- paste("Landscape w. ", patches.made, " patches (", dist.m.sz, " cells each)", sep="")#
		return(out)#
	}#
)
	data(simple)#
	test <- make.landscape(simple, n.patches = 10, type = "s", size = 2)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 4)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 5)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 6)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 7)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 8)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 7)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 8)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 9)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 10)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 11)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 12)#
	plot(test)
# make.landscape method#
#
make.landscape <- function(object, n.patches, type, size, values, keep.nodata, ...) attributes(object)#
setGeneric("make.landscape")#
#
setMethod("make.landscape", "raster",#
	make.landscape <- function(object, n.patches, type = "c", size = 1, values=list(backgr=0, patch=1), keep.nodata=TRUE) {#
		# Size is diameter of circular (c) patches, or side length of square (s) patches#
		n.patches <- round(n.patches)#
		sz2 <- ceiling(size/2)#
		if (!(type %in% c("c", "s"))) stop ("Type must be either 'c' or 's'")#
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points sufficiently far from edge of landscape#
		new.x <- sz2 + 1+round( (out@ncols-2*sz2-1) * runif(n.patches), 0)#
		new.y <- sz2 + 1+round( (out@nrows-2*sz2-1) * runif(n.patches), 0)#
		#
		get.close.pairs <- function(the.x, the.y, s=sz2) {#
			# Try to avoid overlapping patches#
			a <- abs(outer(the.x, the.x, FUN="-"))#
			b <- abs(outer(the.y, the.y, FUN="-"))#
			c <- sqrt(a*a+b*b) < 2*s+1#
			c <- c & lower.tri(c)  # pairs of positions that are too close together#
			rows.to.change <- which(apply(c,1,sum)>=1)#
			#print(c)#
			return (rows.to.change)#
		}#
#
		# Try to avoid overlapping patches#
		rows.to.change <- get.close.pairs(new.x, new.y)#
		all.rows <- 1:length(new.x)#
		rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
		# Change one row at a time, and check if the new point are far enough from others#
		for (rw in rows.to.change) {#
			cont2 <- TRUE#
			stopval<-1#
			#print(paste("Row to chg:", rw))#
			while (cont2 && stopval<100) {#
				new.x[rw] <- sz2 + 1+round( (out@ncols-2*sz2-1) * runif(1), 0)#
				new.y[rw] <- sz2 + 1+round( (out@nrows-2*sz2-1) * runif(1), 0)#
				e <- get.close.pairs(new.x[c(rows.to.keep, rw)], new.y[c(rows.to.keep, rw)])#
				if (length(e)==0) {#
					cont2 <- FALSE#
					rows.to.keep <- sort(c(rw, rows.to.keep))#
				}#
				stopval <- stopval+1#
			}#
			#
			if(stopval==100) {#
				warning(paste("Couldn't disperse point ")) #, (out@nrows-new.y[rw])+out@xllcorner, ",", new.x[rw]+out@yllcorner, sep=""))#
			}#
		}#
		#
#
		# Make new patches#
		if (keep.nodata) out@data[object@data == object@NODATA_value] <- object@NODATA_value#
		patches.made <- 0#
		for (j in 1:length(new.x)) {#
			if (out@data[new.y[j],new.x[j]] != object@NODATA_value) {#
				out@data[new.y[j],new.x[j]] <- values[["patch"]]#
				patches.made <- patches.made + 1#
				if (keep.nodata) out@data[object@data == object@NODATA_value] <- object@NODATA_value#
#
				# type=c -> make circle#
				if(type=="c") {#
					x <- y <- -sz2:sz2#
					dist <- function(x, y) sqrt(x*x + y*y)#
					dist.m <- outer(x,y,dist)#
					dist.m <- dist.m < sz2#
					dist.m.sz <- sum(dist.m)#
					dimnames(dist.m) <- list(x,y)#
					for (m in x){#
						for (n in y) {#
							if( dist.m[as.character(m), as.character(n)] ) {#
								out@data[new.y[j]+n, new.x[j]+m] <- values[["patch"]]#
							}#
						}#
					}#
				} # end type=="c"#
				if(type=="s") {#
					nos <- (-round(size/2)):floor(size/2)#
					x <- y <- nos[(length(nos)-size+1):length(nos)]#
					dist.m <- outer(x,y)#
					dist.m <- dist.m <= 999999#
					dist.m.sz <- sum(dist.m)#
					dimnames(dist.m) <- list(x,y)#
					for (m in x){#
						for (n in y) {#
							if( dist.m[as.character(m), as.character(n)] ) {#
								out@data[new.y[j]+n, new.x[j]+m] <- values[["patch"]]#
							}#
						}#
					}#
				} # end type=="s"#
				#
			}#
		}		#
		if (keep.nodata) out@data[object@data == object@NODATA_value] <- object@NODATA_value#
		out@id <- paste("Landscape w. ", patches.made, " patches (", dist.m.sz, " cells each)", sep="")#
		return(out)#
	}#
)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 12)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 5)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 4)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 3)#
	plot(test)
2
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 2)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 6)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 7)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 6)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 5)#
	plot(test)
# make.landscape method#
#
make.landscape <- function(object, n.patches, type, size, values, keep.nodata, ...) attributes(object)#
setGeneric("make.landscape")#
#
setMethod("make.landscape", "raster",#
	make.landscape <- function(object, n.patches, type = "c", size = 1, values=list(backgr=0, patch=1), keep.nodata=TRUE) {#
		# Size is diameter of circular (c) patches, or side length of square (s) patches#
		n.patches <- round(n.patches)#
		sz2 <- ceiling(size/2)#
		if (!(type %in% c("c", "s"))) stop ("Type must be either 'c' or 's'")#
		out <- object#
		out@data[,] <- values[["backgr"]]#
		# Make center points sufficiently far from edge of landscape#
		new.x <- sz2 + 1+round( (out@ncols-2*sz2-1) * runif(n.patches), 0)#
		new.y <- sz2 + 1+round( (out@nrows-2*sz2-1) * runif(n.patches), 0)#
		#
		get.close.pairs <- function(the.x, the.y, s=sz2) {#
			# Try to avoid overlapping patches#
			a <- abs(outer(the.x, the.x, FUN="-"))#
			b <- abs(outer(the.y, the.y, FUN="-"))#
			c <- sqrt(a*a+b*b) < 2*s+1#
			c <- c & lower.tri(c)  # pairs of positions that are too close together#
			rows.to.change <- which(apply(c,1,sum)>=1)#
			#print(c)#
			return (rows.to.change)#
		}#
#
		# Try to avoid overlapping patches#
		rows.to.change <- get.close.pairs(new.x, new.y)#
		all.rows <- 1:length(new.x)#
		rows.to.keep <- all.rows[!(all.rows %in% rows.to.change)]#
		# Change one row at a time, and check if the new point are far enough from others#
		for (rw in rows.to.change) {#
			cont2 <- TRUE#
			stopval<-1#
			#print(paste("Row to chg:", rw))#
			while (cont2 && stopval<100) {#
				new.x[rw] <- sz2 + 1+round( (out@ncols-2*sz2-1) * runif(1), 0)#
				new.y[rw] <- sz2 + 1+round( (out@nrows-2*sz2-1) * runif(1), 0)#
				e <- get.close.pairs(new.x[c(rows.to.keep, rw)], new.y[c(rows.to.keep, rw)])#
				if (length(e)==0) {#
					cont2 <- FALSE#
					rows.to.keep <- sort(c(rw, rows.to.keep))#
				}#
				stopval <- stopval+1#
			}#
			#
			if(stopval==100) {#
				warning(paste("Couldn't disperse point ")) #, (out@nrows-new.y[rw])+out@xllcorner, ",", new.x[rw]+out@yllcorner, sep=""))#
			}#
		}#
		#
#
		# Make new patches#
		if (keep.nodata) out@data[object@data == object@NODATA_value] <- object@NODATA_value#
		patches.made <- 0#
		for (j in 1:length(new.x)) {#
			if (out@data[new.y[j],new.x[j]] != object@NODATA_value) {#
				out@data[new.y[j],new.x[j]] <- values[["patch"]]#
				patches.made <- patches.made + 1#
				if (keep.nodata) out@data[object@data == object@NODATA_value] <- object@NODATA_value#
#
				# type=c -> make circle#
				if(type=="c") {#
					x <- y <- -sz2:sz2#
					dist <- function(x, y) sqrt(x*x + y*y)#
					dist.m <- outer(x,y,dist)#
					dist.m <- dist.m <= sz2#
					dist.m.sz <- sum(dist.m)#
					dimnames(dist.m) <- list(x,y)#
					for (m in x){#
						for (n in y) {#
							if( dist.m[as.character(m), as.character(n)] ) {#
								out@data[new.y[j]+n, new.x[j]+m] <- values[["patch"]]#
							}#
						}#
					}#
				} # end type=="c"#
				if(type=="s") {#
					nos <- (-round(size/2)):floor(size/2)#
					x <- y <- nos[(length(nos)-size+1):length(nos)]#
					dist.m <- outer(x,y)#
					dist.m <- dist.m <= 999999#
					dist.m.sz <- sum(dist.m)#
					dimnames(dist.m) <- list(x,y)#
					for (m in x){#
						for (n in y) {#
							if( dist.m[as.character(m), as.character(n)] ) {#
								out@data[new.y[j]+n, new.x[j]+m] <- values[["patch"]]#
							}#
						}#
					}#
				} # end type=="s"#
				#
			}#
		}		#
		if (keep.nodata) out@data[object@data == object@NODATA_value] <- object@NODATA_value#
		out@id <- paste("Landscape w. ", patches.made, " patches (", dist.m.sz, " cells each)", sep="")#
		return(out)#
	}#
)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 5)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 6)#
	plot(test)
	data(simple)#
	test <- make.landscape(simple, n.patches = 1, type = "c", size = 7)#
	plot(test)
datasets
data()
data(greatbelt)
plot(greatbelt)
?proj4string
data(sim)
sim01
sim
ls()
data(sim)
my.tracklist <- as.tracklist(sim, sim.02, sim.03)
my.tracklist <- tracklist(sim, sim.02, sim.03)
class(sim)
my.tracklist <- tracklist(list(sim, sim.02, sim.03))
data(sim)#
my.tracklist <- tracklist(list(sim, sim.02, sim.03))#
class(my.tracklist)#
sim.02.obj <- my.tracklist[[2]]
my.tracklist[[1]]
my.tracklist <- as.tracklist(list(sim, sim.02, sim.03))#
class(my.tracklist)#
sim.02.obj <- my.tracklist[[2]]
identical(sim.02, sim.02.object)
my.tracklist <- as.tracklist(list(sim, sim.02, sim.03))#
class(my.tracklist)#
sim.02.obj <- my.tracklist[[2]]
my.tracklist <- as.tracklist(list(sim, sim.02, sim.03))#
class(my.tracklist)#
sim.02.obj <- my.tracklist[[2]]
class(sim.02.obj)
identical(sim.02, sim.02.object)
identical(sim.02, sim.02.obj)
sim.landsc.01 <- make.landscape(greatbelt, 1000, type="s", size=2)
plot(sim.landsc.01)
gb.1000.patches <- make.landscape(greatbelt, 1000, type="s", size=2)#
id(gb.1000.patches)
id(gb.1000.patches)
id(gb.1000.patches) <- "Great Belt w. 536 patches (4 cells each)"
plot(gb.1000.patches, show.levels=FALSE)
id(greatbelt)
plot(gb.1000.patches, col=heat.colors)
getwd()
setwd("/Volumes/nabenielsen/Documents/Porpoise modelling/Porpoise model/raster-data/homogeneous")
dir()
tmp <- read.raster("food-prob01.asc")
dir()
tmp <- read.raster("bathy.asc")
tmp2 <- make.landscape(tmp, 1000, type="s", size=2)
plot(tmp2)
class(tmp2)
class(tmp2)
tmp2 <- make.landscape(tmp, 1000, type="c", size=4, keep.nodata=FALSE)#
plot(tmp2)
